%% Regen Development Run %%
% This is the regen development code for engine analyis. It will use chamber
% properties generated by the main code to evaluate regen circuit seperate
% from primary engine analysis. Eventaually, it will be integrated in the
% main code deck.

%% Solution Architecture %%
% 0 = Inlet, 1 = Outlet
% 1. Solve for initial guess at circuit P0 & dP (P1-P0) using known P1 
%condition and assuming STP density
% 2. Solve for T1 using P0 guess, solve for actual P1
% 3. Guess new P0 based on previously calculated P1, repeat step 2 until
% results converge

%% Input Parameters - run dataCollectionScript.m first%%
fuelStiffness = .29; % 20% injector stiffness
P_ce_req = (P_c/(1-fuelStiffness))*bar;  %Required Coolant exit pressure, Pa
T_ci = 280.15; %Coolant Inlet Temperature, K
%DATA FORMAT:
%R,Z,pip,aeat,mach,cf,ivac,isp,p,t,rho,h,u,mw,cp,gam,son,vis,cond,condfz,pran,pranfz,a_T,q_conv,T_aw
channelFile = 'channelDesign_YJ1S-03.xlsx';
channelProfile = channelProfileGen(channelFile);
%channelProfile Layout
% R, Z, R_floor, R_ceil, numChannels, channelWidth, finWidth, channelDepth, 
%channelCSA, channelPerim, channelAR
[numRows, numCols] = size(engineProps);
channelCSA = channelProfile(:,9);
numChannels = channelProfile(:,5);
channelPerim = channelProfile(:,10);
mDot_chan = mDot_f./numChannels;
Z = channelProfile(:,2);
R_floor = channelProfile(:,3);
R_ceil = channelProfile(:,4);

enginePerf = [R_t, P_c, C_star, R_tCurve]; %Variable Pass vector
%Will have to be reinvestigated
P_cb = 0; %bullshit initialization for bulk inlet pressure, doesn't yet affect properties
T_cb = T_ci; %Set coolant bulk temp to inlet temp
T_wgvec = [];
T_cbvec = [];
T_awvec = [];
T_wcvec = [];
qdot_vec = [];
h_gvec = [];
visc_cvec = [];
rho_cvec = [];
vel_cvec = [];
P_cbvec = [];
transitTime = 0; %initialize clock for coolant transit
for i = numRows:-1:2 % Run heat transfer solution @ station i
    %Iterate heat transfer solution working from chamber exit to Injector
    [rho_cloc,viscK_cloc,cond_cloc, C_pcloc] = jetAProps2(P_cb,T_cb); %Solve for local props
    localProps = [rho_cloc,viscK_cloc,cond_cloc, C_pcloc];
    len = sqrt(((Z(i) - Z(i-1)).^2)+((R_floor(i) - R_floor(i-1)).^2));
    [dT_c, T_wc, T_wg, T_aw, h_g, qdot_ge, vel_c, t_stay] = HTran1D_Solve(T_cb,P_cb,engineProps,channelProfile,localProps,len,mDot_chan(i),enginePerf,i);
    [dPc, ~] = pressureDrop_passage(channelCSA(i),channelPerim(i),mDot_chan(i),rho_cloc,len,viscK_cloc);
    T_cb = T_cb + dT_c;
    T_wgvec(end+1) = T_wg;
    T_cbvec(end+1) = T_cb;
    visc_cvec(end+1) = viscK_cloc;
    rho_cvec(end+1) = rho_cloc;
    T_awvec(end+1) = T_aw;
    T_wcvec(end+1) = T_wc;
    qdot_vec(end+1) = qdot_ge;
    h_gvec(end+1) = h_g;
    vel_cvec(end+1) = vel_c;
    P_cbvec(end+1) = P_cb;
    P_cb = P_cb + dPc;
    transitTime = transitTime + t_stay;
end
%% Reverse them vectors to match coordinate system %%
T_cbvec(end+1) = T_cbvec(end) + (T_cbvec(end)-T_cbvec(end-1)); %apply dT_cb to end of coolant
T_cbvec = fliplr(T_cbvec); %reorient to match engine WCS
T_wgvec(end+1) = T_wgvec(end); %apply N-1 wall temp to end of iteration
T_wgvec = fliplr(T_wgvec);
visc_cvec(end+1) = visc_cvec(end); 
visc_cvec = fliplr(visc_cvec);
rho_cvec(end+1) = rho_cvec(end); 
rho_cvec = fliplr(rho_cvec);
T_awvec(end+1) = T_awvec(end); 
T_awvec = fliplr(T_awvec);
T_wcvec(end+1) = T_wcvec(end); 
T_wcvec = fliplr(T_wcvec);
qdot_vec(end+1) = qdot_vec(end); 
qdot_vec = fliplr(qdot_vec);
h_gvec(end+1) = h_gvec(end); 
h_gvec = fliplr(h_gvec);
vel_cvec(end+1) = vel_cvec(end); 
vel_cvec = fliplr(vel_cvec);
P_cbvec(end+1) = P_cbvec(end); 
P_cbvec = (P_cbvec + P_ce_req)/bar; %convert to Bar



plot(Z, T_wgvec,Z,T_cbvec,Z,h_gvec)
    
    
    
 
    
%% Archive %%     
% for i = numRows:-1:2 % Run heat transfer solution @ station i
%     [rho_cloc,viscK_cloc,cond_cloc, C_pcloc] = jetAProps(P_cb,T_cb); %Solve for local props
%     localProps = [rho_cloc,viscK_cloc,cond_cloc, C_pcloc];
%     len = sqrt(((Z(i) - Z(i-1)).^2)+((R_floor(i) - R_floor(i-1)).^2));
%     [dT_c, T_wc_new, T_wg_new, converge_HT] = HTran1D_Solve(T_cb,P_cb,engineProps,channelProfile,localProps,len,mDot_chan,i);
%     
% end


% %% Solve for initial P0 Guess %%
% disp('Solve for initial P0')
% dP_circuit = 0;
% transitTime_c = 0;
% [rho_camb,viscK_camb,cond_camb, C_pcamb] = jetAProps(P_amb,T_ci); %P_amb irrelevant
% for i = numRows:-1:2 %Invert Indicies to accomodate cooling architecture
%     len = sqrt(((Z(i) - Z(i-1)).^2)+((R_floor(i) - R_floor(i-1)).^2));
%     [dPi, d_hydi] = pressureDrop_passage(channelCSA(i-1),channelProfile((i-1),8),mDot_chan(i-1),rho_camb,len,viscK_camb);
%     dP_circuit = dP_circuit + dPi;
%     transitTime_c = transitTime_c + len./(mDot_chan(i-1)./(rho_camb.*channelCSA(i-1)));
% end

% %% Iterate Heat Transfer Solution %%
% iter = 1 %Iteration count
% P_ciguess = P_ce_req + dP_circuit; %First guess at coolant inlet pressure
% P_cb = P_ciguess; %seed for iteration loop
% converged = false; %exit condition
% 
% 
% 
% 
% 
% 
% %% START WITH THERMAL CLOSURE BEFORE PRESSURE %%
% runProcessor = true;
% if runProcessor
% while ~converged %Iterate until solution criteria reached
%     T_cb = T_ci; %Assign bulk inlet temp to first station
%     dP_circuit = 0;
%     T_wg_old = engineProps(:,26);
%     q_conv_old = engineProps(:,24);
%     T_wg_iter = [];
%     T_wc_iter = [];
%     dT_c_iter = [];
%     for i = numRows:-1:2 % Run heat transfer solution @ station i
%         [rho_cloc,viscK_cloc,cond_cloc, C_pcloc] = jetAProps(P_cb,T_cb); %Solve for local props
%         localProps = [rho_cloc,viscK_cloc,cond_cloc, C_pcloc];
%         len = sqrt(((Z(i) - Z(i-1)).^2)+((R_floor(i) - R_floor(i-1)).^2));
%         [dT_c, T_wc_new, T_wg_new, converge_HT] = HTran1D_Solve(T_cb,P_cb,engineProps,channelProfile,localProps,len,mDot_chan,i);
%         %Solve for coolant heat pickup and new guesses at hotwall temp
%         %Populate vectors with new guesses at current station
%         T_wg_iter(end+1) = T_wg_new;
%         T_wc_iter(end+1) = T_wc_new;
%         dT_c_iter(end+1) = dT_c;
%         T_cb = T_cb+dT_c; %Increment coolant temperature
%     end
%     %Assume same properties carry over to last chamber station as were at
%     %previous station for relevant params - also flip vector back around to
%     %align with engine C.S.
%     T_wg_iter(end+1) = T_wg_iter(end);
%     T_wc_iter(end+1) = T_wc_iter(end);
%     dT_c_iter(end+1) = dT_c_iter(end);
%     T_wg_iter = fliplr(T_wg_iter);
%     T_wc_iter = fliplr(T_wc_iter);
%     dT_c_iter = fliplr(dT_c_iter);
%     [a_T,q_conv,T_aw] = bartzCorrelation(engineProps,T_wg_iter,R_t,P_c,C_star,R_tCurve);
%     engineProps(:,23:26) = [a_T',(q_conv.*fudge)',T_aw',T_wg_iter'];
%     %plot(Z,q_conv)
%     plot(Z,T_wg_iter);
%     hold on
%     if iter > 9
%        converged = true 
%     end
%     iter = iter + 1 %Display iteration count
% end
% end
% T_hotwall_guess = 700; %T_hotwall, K; %initial limit of hotwall temp, Bartz correlation
% T_wg = ones(1,numRows).*T_hotwall_guess; %Hotwall temperature vector, K (for Bartz Correlation)
%Based on material limits, initial guess.
%Populate EngineProps with initial values, for calling/plotting
% query_all = 1:numRows; %query all points for Bartz analysis 
% [a_T,q_conv,T_aw] = bartzCorrelation(engineProps,T_wg,R_t,P_c,C_star,R_tCurve,query_all);
% fudge = 1;
% engineProps = [engineProps,a_T',(q_conv.*fudge)',T_aw',T_wg']; 





